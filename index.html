<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <title>Mapa Mental Din√¢mico</title>
    <base target="_top" />
    
    <style>
      :root {
        --canvas-bg: #f5f6f8;
        --ink: #111111;
        --muted: #4b5563;
        --panel: #ffffff;
        --panel-strong: #f8fafc;
        --border: rgba(17, 17, 17, 0.06);
        --accent: #4c6fff;
        --edge: #b0b6c3;
        --shadow-soft: 0 14px 40px rgba(0, 0, 0, 0.08);
        --shadow-strong: 0 18px 46px rgba(0, 0, 0, 0.12);
        --radius: 16px;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "SF Pro Text", "Inter", system-ui, -apple-system,
          BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: var(--canvas-bg);
        color: var(--ink);
        min-height: 100vh;
        overflow: hidden;
      }

      .app {
        display: flex;
        flex-direction: column;
        min-height: 100vh;
        padding: 20px 24px 16px;
        gap: 12px;
      }

      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 14px;
      }

      .title-block h1 {
        margin: 0;
        font-size: 1.2rem;
        font-weight: 700;
        letter-spacing: -0.01em;
      }

      .title-block small {
        color: var(--muted);
        font-size: 0.9rem;
      }

      .mode-controls {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .mode-indicator {
        padding: 8px 12px;
        border-radius: 12px;
        background: var(--panel);
        color: var(--ink);
        font-weight: 600;
        font-size: 0.92rem;
        border: 1px solid var(--border);
        box-shadow: var(--shadow-soft);
      }

      .ghost-button {
        border: 1px solid var(--border);
        background: var(--panel);
        color: var(--ink);
        border-radius: 12px;
        padding: 10px 14px;
        font-size: 0.95rem;
        cursor: pointer;
        transition: transform 120ms ease, box-shadow 160ms ease;
        box-shadow: var(--shadow-soft);
      }

      .ghost-button:hover:not(:disabled) {
        transform: translateY(-1px);
        box-shadow: var(--shadow-strong);
      }

      .ghost-button:disabled {
        opacity: 0.55;
        cursor: not-allowed;
        box-shadow: none;
      }

      .toolbar {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 10px 12px;
        background: rgba(26, 29, 36, 0.9);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 14px;
        box-shadow: var(--shadow-strong);
        position: fixed;
        top: 18px;
        left: 50%;
        transform: translate(-50%, -10px);
        opacity: 0;
        pointer-events: none;
        transition: opacity 160ms ease, transform 160ms ease;
        flex-wrap: wrap;
        backdrop-filter: blur(8px);
      }

      .toolbar.visible {
        opacity: 1;
        pointer-events: auto;
        transform: translate(-50%, 0);
      }

      .toolbar button,
      .toolbar .file-label,
      .toolbar select,
      .toolbar .status {
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(255, 255, 255, 0.04);
        color: #e6e6e6;
        border-radius: 10px;
        padding: 8px 10px;
        font-size: 0.9rem;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        transition: border-color 0.18s ease, box-shadow 0.2s ease,
          background 0.2s ease;
      }

      .toolbar button:hover,
      .toolbar .file-label:hover,
      .toolbar select:hover {
        border-color: rgba(76, 111, 255, 0.5);
        background: rgba(255, 255, 255, 0.08);
      }

      .toolbar button:disabled {
        opacity: 0.35;
        cursor: not-allowed;
        box-shadow: none;
      }

      .toolbar select {
        appearance: none;
        padding-right: 22px;
        background-image: linear-gradient(45deg, transparent 50%, #e6e6e6 50%),
          linear-gradient(135deg, #e6e6e6 50%, transparent 50%);
        background-position: calc(100% - 16px) calc(50% - 4px),
          calc(100% - 10px) calc(50% - 4px);
        background-size: 6px 6px, 6px 6px;
        background-repeat: no-repeat;
      }

      .status {
        cursor: default;
        font-weight: 600;
        color: var(--ink);
      }

      .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        display: inline-flex;
        background: #22c55e;
      }

      .status.unsaved .status-dot {
        background: #f59e0b;
      }

      .status.saving .status-dot {
        background: #1f4b99;
      }

      .save-bar {
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        height: 3px;
        background: linear-gradient(90deg, rgba(76, 111, 255, 0.3), transparent);
        transform-origin: left;
        scale: 0;
        transition: scale 0.25s ease;
      }

      .save-bar.active {
        scale: 1;
        animation: progress 1.4s linear infinite;
      }

      @keyframes progress {
        from {
          transform: translateX(-20%);
        }
        to {
          transform: translateX(20%);
        }
      }

      .viewport {
        position: relative;
        flex: 1;
        margin: 8px 0 8px;
        border-radius: 18px;
        overflow: hidden;
        background: transparent;
        border: 1px solid var(--border);
        box-shadow: var(--shadow-soft);
      }

      .grid {
        position: absolute;
        inset: 0;
        background: none;
        pointer-events: none;
      }

      #guides {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }

      .map-wrapper {
        position: absolute;
        inset: 0;
        overflow: hidden;
        cursor: grab;
        background: var(--canvas-bg);
      }

      body:not(.edit-mode) .map-wrapper {
        cursor: default;
      }

      .map-inner {
        position: absolute;
        transform-origin: 0 0;
      }

      svg.edges {
        position: absolute;
        inset: 0;
        overflow: visible;
        pointer-events: none;
        transform-origin: 0 0;
      }

      .node {
        position: absolute;
        min-width: 200px;
        max-width: 340px;
        background: var(--panel);
        border: 1px solid rgba(17, 17, 17, 0.04);
        border-radius: var(--radius);
        padding: 14px 16px 12px;
        box-shadow: var(--shadow-soft);
        color: var(--ink);
        display: flex;
        flex-direction: column;
        gap: 8px;
        cursor: grab;
        transition: transform 0.14s ease, box-shadow 0.14s ease,
          border-color 0.18s ease, background 0.18s ease;
      }

      .node:focus-within,
      .node.selected {
        border-color: rgba(76, 111, 255, 0.6);
        box-shadow: var(--shadow-strong);
        transform: translateY(-1px);
        background: #ffffff;
      }

      .node.dragging {
        opacity: 0.97;
        box-shadow: var(--shadow-strong);
      }

      .node-title {
        font-size: 1.05rem;
        font-weight: 600;
        outline: none;
        letter-spacing: -0.01em;
      }

      .node-meta {
        font-size: 0.95rem;
        color: var(--muted);
        display: flex;
        align-items: center;
        gap: 8px;
        outline: none;
        line-height: 1.4;
      }

      .node.read-only .node-title,
      .node.read-only .node-meta {
        cursor: default;
      }

      .node-tags {
        display: inline-flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      .tag {
        padding: 4px 8px;
        border-radius: 999px;
        font-size: 0.78rem;
        background: rgba(76, 111, 255, 0.12);
        border: 1px solid rgba(76, 111, 255, 0.16);
        color: var(--ink);
      }

      .node-actions {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .chip-button {
        border: 1px solid var(--border);
        background: rgba(15, 23, 42, 0.02);
        color: var(--ink);
        border-radius: 10px;
        padding: 6px 10px;
        font-size: 0.85rem;
        cursor: pointer;
        transition: opacity 0.15s ease, border-color 0.2s ease,
          background 0.2s ease;
      }

      .chip-button:hover {
        border-color: rgba(76, 111, 255, 0.4);
        opacity: 1;
        background: rgba(76, 111, 255, 0.08);
      }

      .toast {
        position: fixed;
        bottom: 18px;
        right: 18px;
        padding: 11px 14px;
        border-radius: 12px;
        background: rgba(15, 23, 42, 0.92);
        color: #f8fbff;
        box-shadow: var(--shadow-strong);
        opacity: 0;
        transform: translateY(10px);
        transition: opacity 0.2s ease, transform 0.2s ease;
        font-size: 0.9rem;
      }

      .toast.show {
        opacity: 1;
        transform: translateY(0);
      }

      .mini-toolbar {
        position: absolute;
        display: flex;
        gap: 6px;
        padding: 8px 10px;
        background: rgba(255, 255, 255, 0.98);
        border-radius: 12px;
        border: 1px solid var(--border);
        box-shadow: var(--shadow-soft);
        pointer-events: auto;
      }

      .mini-toolbar button {
        background: rgba(15, 23, 42, 0.04);
        border: 1px solid var(--border);
        color: var(--ink);
        border-radius: 10px;
        padding: 6px;
        cursor: pointer;
      }

      .guide-line {
        position: absolute;
        background: rgba(76, 111, 255, 0.32);
        pointer-events: none;
      }

      .guide-line.vertical {
        width: 1px;
        height: 100%;
      }

      .guide-line.horizontal {
        height: 1px;
        width: 100%;
      }

      .minimap {
        position: absolute;
        bottom: 14px;
        left: 14px;
        width: 200px;
        height: 135px;
        background: rgba(255, 255, 255, 0.92);
        border: 1px solid var(--border);
        border-radius: 14px;
        box-shadow: var(--shadow-soft);
        padding: 8px;
        backdrop-filter: blur(8px);
      }

      .minimap canvas {
        width: 100%;
        height: 100%;
      }

      .history {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      .history span {
        background: rgba(15, 23, 42, 0.04);
        border: 1px solid var(--border);
        padding: 4px 8px;
        border-radius: 8px;
        font-size: 0.78rem;
        color: var(--muted);
      }

      .save-progress {
        width: 120px;
        height: 8px;
        background: rgba(15, 23, 42, 0.04);
        border: 1px solid var(--border);
        border-radius: 999px;
        position: relative;
        overflow: hidden;
      }

      .save-progress span {
        position: absolute;
        inset: 0;
        background: linear-gradient(90deg, var(--primary), var(--accent));
        transform-origin: left;
        transform: scaleX(0);
        transition: transform 0.25s ease;
      }

      .save-progress.active span {
        transform: scaleX(1);
        animation: pulse 1.2s ease infinite alternate;
      }

      @keyframes pulse {
        from {
          opacity: 0.65;
        }
        to {
          opacity: 1;
        }
      }

      @media (max-width: 960px) {
        .floating-card {
          display: none;
        }
        .minimap {
          display: none;
        }
        .node {
          min-width: 160px;
        }
      }
    </style>

  </head>
  <body>
    <div class="app" aria-label="Mapa" role="application">
      <header>
        <div class="title-block">
          <h1>Salas conectadas</h1>
          <small>Canvas controlado e limpo</small>
        </div>
        <div class="mode-controls">
          <div class="mode-indicator" id="modeIndicator">Explorar</div>
          <button id="modeToggle" class="ghost-button">Editar</button>
        </div>
      </header>

      <div class="toolbar" id="toolbar" aria-label="Ferramentas de edi√ß√£o">
        <button id="btnAddChild" aria-label="Adicionar filho">Ôºã Filho</button>
        <button id="btnAddSibling" aria-label="Adicionar irm√£o">Ôºã Irm√£o</button>
        <button id="btnDelete" aria-label="Remover n√≥ selecionado">‚úï Remover</button>
        <button id="btnOrganize" aria-label="Organizar">‚§∑ Organizar</button>
        <button id="btnCollapse" aria-label="Expandir ou colapsar">‚§µÔ∏é Alternar</button>
        <button id="btnUndo" aria-label="Desfazer">‚Ü©Ô∏é Desfazer</button>
        <button id="btnRedo" aria-label="Refazer">‚Ü™Ô∏é Refazer</button>
        <button id="btnSave" aria-label="Salvar manual">‚ßâ Salvar</button>
        <button id="btnExport" aria-label="Exportar JSON">‚¨áÔ∏é Exportar</button>
        <label class="file-label" for="fileImport">‚¨ÜÔ∏é Importar</label>
        <input id="fileImport" type="file" accept="application/json" style="display:none" />
        <select id="versionSelector" aria-label="Vers√µes salvas"></select>
        <span class="status" id="syncStatus" role="status" aria-live="polite">
          <span class="status-dot"></span> <strong>Sincronizado</strong>
        </span>
        <div class="save-progress" aria-label="Estado de grava√ß√£o">
          <span id="saveProgressBar"></span>
        </div>
      </div>

      <div class="viewport" id="viewport" role="presentation">
        <div class="save-bar" id="saveBar"></div>
        <div class="grid" aria-hidden="true"></div>
        <div id="guides"></div>
        <div class="map-wrapper" id="mapWrapper" aria-label="√Årea do mapa">
          <svg class="edges" id="edgeLayer" xmlns="http://www.w3.org/2000/svg"></svg>
          <div class="map-inner" id="mapInner" aria-live="polite"></div>
        </div>
        <div class="minimap" aria-label="Minimapa" title="Clique para reposicionar" role="button">
          <canvas id="minimapCanvas" width="220" height="150"></canvas>
        </div>
      </div>
    </div>

    <div class="mini-toolbar" id="miniToolbar" aria-label="A√ß√µes r√°pidas" hidden>
      <button id="miniAddChild" aria-label="Adicionar filho">Ôºã</button>
      <button id="miniAddSibling" aria-label="Adicionar irm√£o">‚ßâ</button>
      <button id="miniDelete" aria-label="Excluir n√≥">üóëÔ∏è</button>
    </div>

    <div class="toast" id="toast" role="status" aria-live="polite"></div>

    <script>
      const mapInner = document.getElementById("mapInner");
      const edgeLayer = document.getElementById("edgeLayer");
      const viewport = document.getElementById("viewport");
      const mapWrapper = document.getElementById("mapWrapper");
      const toast = document.getElementById("toast");
      const syncStatus = document.getElementById("syncStatus");
      const saveBar = document.getElementById("saveBar");
      const saveProgressBar = document.getElementById("saveProgressBar");
      const guidesContainer = document.getElementById("guides");
      const minimapCanvas = document.getElementById("minimapCanvas");
      const miniToolbar = document.getElementById("miniToolbar");
      const historyList = document.getElementById("historyList");
      const toolbar = document.getElementById("toolbar");
      const modeToggle = document.getElementById("modeToggle");
      const modeIndicator = document.getElementById("modeIndicator");

      const btnAddChild = document.getElementById("btnAddChild");
      const btnAddSibling = document.getElementById("btnAddSibling");
      const btnDelete = document.getElementById("btnDelete");
      const btnOrganize = document.getElementById("btnOrganize");
      const btnCollapse = document.getElementById("btnCollapse");
      const btnUndo = document.getElementById("btnUndo");
      const btnRedo = document.getElementById("btnRedo");
      const btnSave = document.getElementById("btnSave");
      const btnExport = document.getElementById("btnExport");
      const fileImport = document.getElementById("fileImport");
      const versionSelector = document.getElementById("versionSelector");
      const miniAddChild = document.getElementById("miniAddChild");
      const miniAddSibling = document.getElementById("miniAddSibling");
      const miniDelete = document.getElementById("miniDelete");

      const MAX_TITLE = 80;
      const MAX_DESCRIPTION = 200;

      const UI_CONFIG = {
        canvas: {
          background: "#f5f6f8",
          gridOpacity: 0,
          guide: "rgba(76, 111, 255, 0.35)",
        },
        nodes: {
          background: "#ffffff",
          highlight: "#4c6fff",
          text: "#111111",
          muted: "#4b5563",
          radius: 16,
          shadow: "0 14px 40px rgba(0,0,0,0.08)",
          shadowActive: "0 18px 46px rgba(0,0,0,0.12)",
        },
        edges: {
          color: "#b0b6c3",
          width: 1.6,
          inactiveOpacity: 0.25,
          activeOpacity: 0.9,
        },
        toolbar: {
          requireSelection: true,
        },
        interactions: {
          snap: 12,
          miniToolbar: true,
        },
      };

      let mapState = { nodes: [], rootId: null };
      let nodeElements = new Map();
      let selectedId = null;
      let editMode = false;
      let isDraggingNode = false;
      let dragOffset = { x: 0, y: 0 };
      let panState = { x: 200, y: 120, scale: 1, targetScale: 1 };
      let isPanning = false;
      let panStart = { x: 0, y: 0 };
      const undoStack = [];
      const redoStack = [];
      let historyLog = [];
      let savePending = false;
      let saveTimer = null;
      let saveInFlight = false;

      function applyVisualConfig() {
        const root = document.documentElement;
        root.style.setProperty("--canvas-bg", UI_CONFIG.canvas.background);
        root.style.setProperty("--panel", UI_CONFIG.nodes.background);
        root.style.setProperty("--ink", UI_CONFIG.nodes.text);
        root.style.setProperty("--muted", UI_CONFIG.nodes.muted);
        root.style.setProperty("--accent", UI_CONFIG.nodes.highlight);
        root.style.setProperty("--edge", UI_CONFIG.edges.color);
        root.style.setProperty("--radius", `${UI_CONFIG.nodes.radius}px`);
        root.style.setProperty("--shadow-soft", UI_CONFIG.nodes.shadow);
        root.style.setProperty("--shadow-strong", UI_CONFIG.nodes.shadowActive);
      }

      function defaultMap() {
        const rootId = crypto.randomUUID();
        const salas = [
          {
            title: "Recep√ß√£o",
            description: "Acolhimento e registros",
            color: "#38bdf8",
          },
          {
            title: "Triagem",
            description: "Avalia√ß√£o inicial de pacientes",
            color: "#c084fc",
          },
          {
            title: "Sala Amarela",
            description: "Cuidados intermedi√°rios",
            color: "#f59e0b",
          },
          {
            title: "Sala Vermelha",
            description: "Emerg√™ncias cr√≠ticas",
            color: "#ef4444",
          },
          {
            title: "Centro Cir√∫rgico",
            description: "Procedimentos cir√∫rgicos",
            color: "#22c55e",
          },
          {
            title: "UTI",
            description: "Cuidados intensivos",
            color: "#3b82f6",
          },
        ];

        const spacing = 140;
        const offsetY = -((salas.length - 1) * spacing) / 2;

        return {
          rootId,
          nodes: [
            {
              id: rootId,
              parentId: null,
              title: "Hospital Estadual",
              description: "Rede das salas ativas",
              tags: ["hospital", "dashboard"],
              collapsed: false,
              position: { x: 0, y: 0 },
              color: "#60a5fa",
            },
            ...salas.map((sala, idx) => ({
              id: crypto.randomUUID(),
              parentId: rootId,
              title: sala.title,
              description: sala.description,
              tags: ["sala"],
              collapsed: false,
              position: { x: 260, y: offsetY + idx * spacing },
              color: sala.color,
            })),
          ],
        };
      }

      function showToast(message) {
        toast.textContent = message;
        toast.classList.add("show");
        setTimeout(() => toast.classList.remove("show"), 2200);
      }

      function setStatus(unsaved, saving = false) {
        savePending = unsaved;
        saveInFlight = saving;
        const dot = syncStatus.querySelector(".status-dot");
        const label = syncStatus.querySelector("strong");
        syncStatus.classList.toggle("unsaved", unsaved && !saving);
        syncStatus.classList.toggle("saving", saving);
        document.querySelector(".save-progress").classList.toggle("active", unsaved || saving);
        saveBar.classList.toggle("active", saving);
        saveProgressBar.parentElement.classList.toggle("active", saving);
        if (saving) {
          dot.style.boxShadow = "0 0 0 6px rgba(76,111,255,0.2)";
          label.textContent = "Salvando";
        } else if (unsaved) {
          dot.style.boxShadow = "0 0 0 6px rgba(245,158,11,0.2)";
          label.textContent = "Pendente";
        } else {
          dot.style.boxShadow = "0 0 0 6px rgba(34,197,94,0.2)";
          label.textContent = "Sincronizado";
        }
      }

      function updateToolbarVisibility() {
        const show =
          editMode &&
          (!UI_CONFIG.toolbar.requireSelection || Boolean(selectedId));
        toolbar.classList.toggle("visible", show);
      }

      function setMode(isEdit) {
        editMode = isEdit;
        document.body.classList.toggle("edit-mode", editMode);
        modeIndicator.textContent = editMode ? "Editar" : "Explorar";
        modeToggle.textContent = editMode ? "Explorar" : "Editar";

        [
          btnAddChild,
          btnAddSibling,
          btnDelete,
          btnOrganize,
          btnCollapse,
          btnUndo,
          btnRedo,
          btnSave,
          btnExport,
          fileImport,
          versionSelector,
        ].forEach((el) => {
          if (!el) return;
          el.disabled = !editMode;
        });

        if (!editMode) {
          isDraggingNode = false;
          miniToolbar.hidden = true;
        }

        updateToolbarVisibility();
        render();
      }

      function requireEdit(action = "editar") {
        if (editMode) return true;
        showToast(`Ative o modo editar para ${action}.`);
        return false;
      }

      function pushHistory(label = "altera√ß√£o") {
        undoStack.push(JSON.stringify(mapState));
        historyLog.unshift(`${new Date().toLocaleTimeString()} ¬∑ ${label}`);
        if (undoStack.length > 60) undoStack.shift();
        if (historyLog.length > 10) historyLog.pop();
        redoStack.length = 0;
        renderHistory();
      }

      function renderHistory() {
        if (!historyList) return;
        historyList.innerHTML = historyLog
          .map((item) => `<span>${item}</span>`)
          .join("");
      }

      function loadFromServer() {
        if (typeof google !== "undefined" && google.script) {
          google.script.run
            .withSuccessHandler((data) => {
              mapState = data && data.nodes ? data : defaultMap();
              selectedId = mapState.rootId;
              render();
              setStatus(false, false);
              loadVersions();
            })
            .withFailureHandler(() => {
              mapState = defaultMap();
              selectedId = mapState.rootId;
              render();
              setStatus(false, false);
              loadVersions();
            })
            .getMap();
        } else {
          mapState = defaultMap();
          selectedId = mapState.rootId;
          render();
          setStatus(false, false);
          loadVersions();
        }
      }

      function persistVersion() {
        const versions = JSON.parse(localStorage.getItem("mapVersions") || "[]");
        versions.unshift({
          savedAt: new Date().toISOString(),
          data: mapState,
        });
        if (versions.length > 8) versions.pop();
        localStorage.setItem("mapVersions", JSON.stringify(versions));
        loadVersions();
      }

      function loadVersions() {
        const versions = JSON.parse(localStorage.getItem("mapVersions") || "[]");
        versionSelector.innerHTML = "";
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "Vers√µes locais";
        versionSelector.appendChild(opt);
        versions.forEach((v, idx) => {
          const option = document.createElement("option");
          const date = new Date(v.savedAt);
          option.value = idx;
          option.textContent = `${idx + 1} ‚Ä¢ ${date.toLocaleString()}`;
          versionSelector.appendChild(option);
        });
      }

      function saveToServer(debounced = true) {
        setStatus(true, true);
        clearTimeout(saveTimer);
        saveTimer = setTimeout(() => {
          if (typeof google !== "undefined" && google.script) {
            google.script.run
              .withSuccessHandler(() => {
                setStatus(false, false);
                showToast("Mapa salvo na planilha");
                persistVersion();
              })
              .withFailureHandler(() => showToast("Falha ao salvar"))
              .setMap(mapState);
          } else {
            setStatus(false, false);
            persistVersion();
          }
        }, debounced ? 350 : 0);
      }

      function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }

      function validateText(value, max, fallback) {
        const trimmed = (value || "").trim();
        if (!trimmed) return fallback;
        if (trimmed.length > max) {
          showToast(`Limite de ${max} caracteres aplicado.`);
        }
        return trimmed.slice(0, max);
      }

      function render() {
        mapInner.innerHTML = "";
        edgeLayer.innerHTML = "";
        nodeElements = new Map();
        const visible = new Set();

        const mapById = new Map(mapState.nodes.map((n) => [n.id, n]));

        function isVisible(node) {
          let current = node;
          while (current) {
            if (current.collapsed && current.id !== node.id) return false;
            current = mapById.get(current.parentId);
          }
          return true;
        }

        mapState.nodes.forEach((node) => {
          if (!isVisible(node)) return;
          visible.add(node.id);
          const el = document.createElement("div");
          el.className =
            "node" +
            (node.id === selectedId ? " selected" : "") +
            (editMode ? "" : " read-only");
          el.dataset.nodeId = node.id;
          el.style.left = `${node.position.x}px`;
          el.style.top = `${node.position.y}px`;
          el.style.borderColor = node.color || "var(--border)";
          el.setAttribute("role", "group");
          el.setAttribute("aria-label", `${node.title}`);
          nodeElements.set(node.id, el);

          const title = document.createElement("div");
          title.className = "node-title";
          title.contentEditable = editMode ? "true" : "false";
          title.textContent = node.title;
          title.setAttribute("role", "textbox");
          title.setAttribute("aria-label", "T√≠tulo do n√≥");
          title.addEventListener("input", () => {
            node.title = validateText(title.textContent, MAX_TITLE, "Sem nome");
            setStatus(true, true);
            saveToServer();
          });

          const meta = document.createElement("div");
          meta.className = "node-meta";
          meta.textContent = node.description || "Sem descri√ß√£o";
          meta.contentEditable = editMode ? "true" : "false";
          meta.setAttribute("role", "textbox");
          meta.setAttribute("aria-label", "Descri√ß√£o do n√≥");
          meta.addEventListener("input", () => {
            node.description = validateText(meta.textContent, MAX_DESCRIPTION, "Sem descri√ß√£o");
            setStatus(true, true);
            saveToServer();
          });

          const tags = document.createElement("div");
          tags.className = "node-tags";
          (node.tags || []).forEach((tag) => {
            const t = document.createElement("span");
            t.className = "tag";
            t.textContent = tag;
            tags.appendChild(t);
          });

          const actions = document.createElement("div");
          actions.className = "node-actions";
          const toggle = document.createElement("button");
          toggle.className = "chip-button";
          toggle.textContent = node.collapsed ? "Expandir" : "Colapsar";
          toggle.disabled = !editMode;
          toggle.title = editMode ? "" : "Dispon√≠vel no modo editar";
          toggle.addEventListener("click", (e) => {
            e.stopPropagation();
            node.collapsed = !node.collapsed;
            pushHistory("alternar colapso");
            render();
            saveToServer();
          });
          actions.appendChild(toggle);

          if (node.collapsed) {
            const hint = document.createElement("div");
            hint.className = "collapsed-hint";
            hint.textContent = "Filhos ocultos";
            actions.appendChild(hint);
          }

          el.appendChild(title);
          el.appendChild(meta);
          el.appendChild(tags);
          el.appendChild(actions);

          el.addEventListener("pointerdown", (e) => {
            if (e.button !== 0) return;
            selectedId = node.id;
            el.classList.add("selected");
            if (!editMode) {
              miniToolbar.hidden = true;
              return;
            }
            isDraggingNode = true;
            el.classList.add("dragging");
            dragOffset = { x: e.clientX - node.position.x, y: e.clientY - node.position.y };
            el.setPointerCapture(e.pointerId);
            showMiniToolbar(el);
          });

          el.addEventListener("pointermove", (e) => {
            if (!editMode || !isDraggingNode || selectedId !== node.id) return;
            const x = (e.clientX - dragOffset.x) / panState.scale;
            const y = (e.clientY - dragOffset.y) / panState.scale;
            const { snappedX, snappedY } = applyAlignment(x, y, node.id);
            node.position = { x: snappedX, y: snappedY };
            el.style.left = `${snappedX}px`;
            el.style.top = `${snappedY}px`;
            drawEdges();
            setStatus(true, true);
          });

          el.addEventListener("pointerup", (e) => {
            if (editMode && isDraggingNode) {
              el.releasePointerCapture(e.pointerId);
              isDraggingNode = false;
              el.classList.remove("dragging");
              clearGuides();
              spreadSiblings(node);
              saveToServer();
            }
          });

          el.addEventListener("click", (e) => {
            e.stopPropagation();
            selectedId = node.id;
            render();
          });

          mapInner.appendChild(el);
        });

        updateToolbarVisibility();
        drawEdges();
        if (editMode) {
          showMiniToolbar(nodeElements.get(selectedId));
        } else {
          miniToolbar.hidden = true;
        }
        drawMinimap();
      }

      function drawEdges() {
        edgeLayer.setAttribute(
          "viewBox",
          `0 0 ${viewport.clientWidth} ${viewport.clientHeight}`
        );
        edgeLayer.innerHTML = "";
        const nodes = new Map(mapState.nodes.map((n) => [n.id, n]));
        mapState.nodes.forEach((node) => {
          if (!node.parentId) return;
          const parent = nodes.get(node.parentId);
          if (!parent || parent.collapsed) return;
          const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
          const parentEl = nodeElements.get(parent.id);
          const nodeEl = nodeElements.get(node.id);
          const parentWidth = parentEl?.offsetWidth || 170;
          const parentHeight = parentEl?.offsetHeight || 80;
          const nodeHeight = nodeEl?.offsetHeight || 80;
          const start = {
            x: parent.position.x + parentWidth,
            y: parent.position.y + parentHeight / 2,
          };
          const end = { x: node.position.x, y: node.position.y + nodeHeight / 2 };
          const dx = (end.x - start.x) / 2;
          const d = `M ${start.x} ${start.y} C ${start.x + dx} ${start.y}, ${end.x - dx} ${end.y}, ${end.x} ${end.y}`;
          const active =
            selectedId &&
            (node.id === selectedId || node.parentId === selectedId || parent.id === selectedId);
          path.setAttribute("d", d);
          path.setAttribute("fill", "none");
          path.setAttribute("stroke", UI_CONFIG.edges.color);
          path.setAttribute(
            "stroke-width",
            active ? UI_CONFIG.edges.width * 1.25 : UI_CONFIG.edges.width
          );
          path.setAttribute(
            "opacity",
            active ? UI_CONFIG.edges.activeOpacity : UI_CONFIG.edges.inactiveOpacity
          );
          path.setAttribute("stroke-linecap", "round");
          edgeLayer.appendChild(path);
        });
        applyTransform();
      }

      function applyTransform() {
        mapInner.style.transform = `translate(${panState.x}px, ${panState.y}px) scale(${panState.scale})`;
        edgeLayer.style.transform = mapInner.style.transform;
      }

      function addNode(parentId, label = "novo item") {
        if (!requireEdit("criar n√≥s")) return;
        if (!parentId) parentId = mapState.rootId;
        pushHistory(label);
        const newNode = {
          id: crypto.randomUUID(),
          parentId,
          title: "Item",
          description: "Detalhe",
          tags: [],
          collapsed: false,
          position: { x: Math.random() * 160 + 80, y: Math.random() * 120 - 60 },
          color: UI_CONFIG.nodes.highlight,
        };
        mapState.nodes.push(newNode);
        selectedId = newNode.id;
        render();
        saveToServer();
      }

      function deleteNode(nodeId) {
        if (!requireEdit("apagar")) return;
        if (!nodeId) return;
        pushHistory("excluir");
        const toDelete = new Set([nodeId]);
        let changed = true;
        while (changed) {
          changed = false;
          mapState.nodes.forEach((n) => {
            if (toDelete.has(n.parentId) && !toDelete.has(n.id)) {
              toDelete.add(n.id);
              changed = true;
            }
          });
        }
        mapState.nodes = mapState.nodes.filter((n) => !toDelete.has(n.id));
        selectedId = mapState.rootId;
        render();
        saveToServer();
      }

      function autoLayout() {
        if (!requireEdit("organizar")) return;
        pushHistory("auto organizar");
        const nodes = mapState.nodes;
        const levels = {};
        const root = nodes.find((n) => !n.parentId || n.id === mapState.rootId);
        const byParent = nodes.reduce((acc, n) => {
          acc[n.parentId || "root"] = acc[n.parentId || "root"] || [];
          acc[n.parentId || "root"].push(n);
          return acc;
        }, {});

        function layout(node, depth, angleStart, angleEnd) {
          levels[depth] = levels[depth] || 0;
          const angle = (angleStart + angleEnd) / 2;
          const radius = depth * 200;
          node.position = {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
          };
          const children = byParent[node.id] || [];
          const slice = (angleEnd - angleStart) / Math.max(children.length, 1);
          children.forEach((child, idx) => {
            layout(child, depth + 1, angleStart + slice * idx, angleStart + slice * (idx + 1));
          });
        }

        layout(root, 0, -Math.PI / 2, Math.PI / 2);
        render();
        saveToServer();
      }

      function toggleCollapse() {
        if (!requireEdit("colapsar")) return;
        const node = mapState.nodes.find((n) => n.id === selectedId);
        if (!node) return;
        pushHistory("colapsar/expandir");
        node.collapsed = !node.collapsed;
        render();
        saveToServer();
      }

      function addChildShortcut() {
        if (!requireEdit("criar filhos")) return;
        const target = selectedId || mapState.rootId;
        addNode(target, "novo filho");
      }

      function addSiblingShortcut() {
        if (!requireEdit("criar irm√£os")) return;
        const node = mapState.nodes.find((n) => n.id === selectedId);
        const parent = node ? node.parentId : mapState.rootId;
        addNode(parent, "novo irm√£o");
      }

      function handleUndo() {
        if (!requireEdit("desfazer")) return;
        if (!undoStack.length) return;
        const last = undoStack.pop();
        redoStack.push(JSON.stringify(mapState));
        mapState = JSON.parse(last);
        render();
      }

      function handleRedo() {
        if (!requireEdit("refazer")) return;
        if (!redoStack.length) return;
        undoStack.push(JSON.stringify(mapState));
        mapState = JSON.parse(redoStack.pop());
        render();
      }

      function handleSave() {
        if (!requireEdit("salvar")) return;
        saveToServer(false);
      }

      function setupPanZoom() {
        viewport.addEventListener("pointerdown", (e) => {
          if (e.target.closest(".node")) return;
          isPanning = true;
          panStart = { x: e.clientX - panState.x, y: e.clientY - panState.y };
          mapWrapper.style.cursor = "grabbing";
        });

        viewport.addEventListener("pointermove", (e) => {
          if (!isPanning) return;
          panState.x = e.clientX - panStart.x;
          panState.y = e.clientY - panStart.y;
          drawEdges();
        });

        window.addEventListener("pointerup", () => {
          isPanning = false;
          mapWrapper.style.cursor = "grab";
        });

        viewport.addEventListener("wheel", (e) => {
          e.preventDefault();
          const rect = viewport.getBoundingClientRect();
          const cursorX = (e.clientX - rect.left - panState.x) / panState.scale;
          const cursorY = (e.clientY - rect.top - panState.y) / panState.scale;
          const deltaScale = -e.deltaY * 0.0012;
          const desired = clamp(panState.scale + deltaScale, 0.6, 2.4);
          panState.scale = panState.scale + (desired - panState.scale) * 0.35;
          panState.targetScale = desired;
          panState.x = e.clientX - rect.left - cursorX * panState.scale;
          panState.y = e.clientY - rect.top - cursorY * panState.scale;
          drawEdges();
        });

        function animateZoom() {
          if (Math.abs(panState.targetScale - panState.scale) > 0.001) {
            panState.scale = panState.scale + (panState.targetScale - panState.scale) * 0.18;
            drawEdges();
          }
          requestAnimationFrame(animateZoom);
        }

        animateZoom();
      }

      function setupHotkeys() {
        document.addEventListener("keydown", (e) => {
          if (e.key === "Enter" && e.shiftKey) {
            e.preventDefault();
            addChildShortcut();
          } else if (e.key === "Enter") {
            e.preventDefault();
            if (!editMode) return showToast("Ative o modo editar para digitar.");
            focusSelectedForEdit();
          } else if (e.key === "Delete") {
            e.preventDefault();
            deleteNode(selectedId);
          } else if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === "s") {
            e.preventDefault();
            handleSave();
          } else if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === "z") {
            e.preventDefault();
            handleUndo();
          } else if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === "y") {
            e.preventDefault();
            handleRedo();
          } else if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
            e.preventDefault();
            navigateNodes(e.key);
          }
        });
      }

      function focusSelectedForEdit() {
        const el = nodeElements.get(selectedId);
        if (!el) return;
        const title = el.querySelector(".node-title");
        if (title) {
          title.focus();
          document.getSelection()?.selectAllChildren(title);
        }
      }

      function bindButtons() {
        btnAddChild.addEventListener("click", addChildShortcut);
        btnAddSibling.addEventListener("click", addSiblingShortcut);
        btnDelete.addEventListener("click", () => deleteNode(selectedId));
        btnOrganize.addEventListener("click", autoLayout);
        btnCollapse.addEventListener("click", toggleCollapse);
        btnUndo.addEventListener("click", handleUndo);
        btnRedo.addEventListener("click", handleRedo);
        btnSave.addEventListener("click", handleSave);
        btnExport.addEventListener("click", exportJSON);
        fileImport.addEventListener("change", importJSON);
        versionSelector.addEventListener("change", restoreVersion);
        miniAddChild.addEventListener("click", () => addChildShortcut());
        miniAddSibling.addEventListener("click", () => addSiblingShortcut());
        miniDelete.addEventListener("click", () => deleteNode(selectedId));
        minimapCanvas.parentElement.addEventListener("click", minimapNavigate);
        modeToggle.addEventListener("click", () => setMode(!editMode));
      }

      function applyAlignment(x, y, currentId) {
        const threshold = UI_CONFIG.interactions.snap;
        let snappedX = x;
        let snappedY = y;
        let guideX = null;
        let guideY = null;
        mapState.nodes.forEach((n) => {
          if (n.id === currentId) return;
          if (Math.abs(n.position.x - x) < threshold) {
            snappedX = n.position.x;
            guideX = snappedX;
          }
          if (Math.abs(n.position.y - y) < threshold) {
            snappedY = n.position.y;
            guideY = snappedY;
          }
        });
        renderGuides(guideX, guideY);
        return { snappedX, snappedY };
      }

      function renderGuides(x, y) {
        guidesContainer.innerHTML = "";
        if (x !== null) {
          const v = document.createElement("div");
          v.className = "guide-line vertical";
          v.style.left = `${x}px`;
          guidesContainer.appendChild(v);
        }
        if (y !== null) {
          const h = document.createElement("div");
          h.className = "guide-line horizontal";
          h.style.top = `${y}px`;
          guidesContainer.appendChild(h);
        }
      }

      function clearGuides() {
        guidesContainer.innerHTML = "";
      }

      function spreadSiblings(node) {
        const siblings = mapState.nodes.filter((n) => n.parentId === node.parentId && n.id !== node.id);
        siblings.forEach((sib) => {
          const dx = sib.position.x - node.position.x;
          const dy = sib.position.y - node.position.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 60) {
            sib.position.x += dx * 0.2 + 30;
            sib.position.y += dy * 0.2 + 30;
          }
        });
        drawEdges();
      }

      function navigateNodes(key) {
        if (!selectedId || !mapState.nodes.length) return;
        const current = mapState.nodes.find((n) => n.id === selectedId);
        if (!current) return;
        const dirMap = {
          ArrowUp: { x: 0, y: -1 },
          ArrowDown: { x: 0, y: 1 },
          ArrowLeft: { x: -1, y: 0 },
          ArrowRight: { x: 1, y: 0 },
        };
        const dir = dirMap[key];
        let best = null;
        let bestScore = -Infinity;
        mapState.nodes.forEach((n) => {
          if (n.id === current.id) return;
          const vx = n.position.x - current.position.x;
          const vy = n.position.y - current.position.y;
          const dot = vx * dir.x + vy * dir.y;
          if (dot <= 0) return;
          const dist = Math.sqrt(vx * vx + vy * vy);
          const score = dot / (dist + 1e-6);
          if (score > bestScore) {
            bestScore = score;
            best = n;
          }
        });
        if (best) {
          selectedId = best.id;
          render();
        }
      }

      function drawMinimap() {
        const ctx = minimapCanvas.getContext("2d");
        ctx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
        const nodes = mapState.nodes;
        if (!nodes.length) return;
        const xs = nodes.map((n) => n.position.x);
        const ys = nodes.map((n) => n.position.y);
        const minX = Math.min(...xs) - 80;
        const maxX = Math.max(...xs) + 200;
        const minY = Math.min(...ys) - 80;
        const maxY = Math.max(...ys) + 80;
        const mapW = maxX - minX;
        const mapH = maxY - minY;
        const scale = Math.min(
          minimapCanvas.width / (mapW || 1),
          minimapCanvas.height / (mapH || 1)
        );
        ctx.fillStyle = "rgba(255,255,255,0.05)";
        ctx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);
        nodes.forEach((n) => {
          const x = (n.position.x - minX) * scale;
          const y = (n.position.y - minY) * scale;
          ctx.fillStyle =
            n.id === selectedId
              ? "rgba(76,111,255,0.9)"
              : "rgba(255,255,255,0.6)";
          ctx.fillRect(x, y, 8, 8);
        });
        const viewW = viewport.clientWidth / panState.scale;
        const viewH = viewport.clientHeight / panState.scale;
        const viewX = (-panState.x - minX) * scale;
        const viewY = (-panState.y - minY) * scale;
        ctx.strokeStyle = "rgba(76,111,255,0.8)";
        ctx.lineWidth = 2;
        ctx.strokeRect(viewX, viewY, viewW * scale, viewH * scale);
      }

      function minimapNavigate(e) {
        const rect = minimapCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const nodes = mapState.nodes;
        if (!nodes.length) return;
        const xs = nodes.map((n) => n.position.x);
        const ys = nodes.map((n) => n.position.y);
        const minX = Math.min(...xs) - 80;
        const maxX = Math.max(...xs) + 200;
        const minY = Math.min(...ys) - 80;
        const maxY = Math.max(...ys) + 80;
        const mapW = maxX - minX;
        const mapH = maxY - minY;
        const scale = Math.min(
          minimapCanvas.width / (mapW || 1),
          minimapCanvas.height / (mapH || 1)
        );
        const worldX = x / scale + minX;
        const worldY = y / scale + minY;
        panState.x = viewport.clientWidth / 2 - worldX * panState.scale;
        panState.y = viewport.clientHeight / 2 - worldY * panState.scale;
        drawEdges();
      }

      function showMiniToolbar(nodeEl) {
        if (!editMode || !nodeEl || !UI_CONFIG.interactions.miniToolbar) {
          miniToolbar.hidden = true;
          return;
        }
        const rect = nodeEl.getBoundingClientRect();
        const parentRect = viewport.getBoundingClientRect();
        miniToolbar.style.left = `${rect.left - parentRect.left + rect.width / 2 - 70}px`;
        miniToolbar.style.top = `${rect.top - parentRect.top - 40}px`;
        miniToolbar.hidden = false;
      }

      function exportJSON() {
        const dataStr = JSON.stringify(mapState, null, 2);
        const blob = new Blob([dataStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `mapa-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
      }

      function importJSON(event) {
        const file = event.target.files?.[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const parsed = JSON.parse(e.target.result);
            if (!parsed.nodes || !parsed.rootId) throw new Error("Arquivo inv√°lido");
            pushHistory("importar JSON");
            mapState = parsed;
            selectedId = mapState.rootId;
            render();
            saveToServer();
          } catch (err) {
            showToast("Falha ao importar JSON");
          }
        };
        reader.readAsText(file);
        event.target.value = "";
      }

      function restoreVersion(e) {
        const idx = e.target.value;
        if (idx === "") return;
        const versions = JSON.parse(localStorage.getItem("mapVersions") || "[]");
        const version = versions[Number(idx)];
        if (version) {
          pushHistory("restaurar vers√£o");
          mapState = version.data;
          selectedId = mapState.rootId;
          render();
          saveToServer();
        }
      }

      applyVisualConfig();
      setMode(false);
      loadFromServer();
      setupPanZoom();
      setupHotkeys();
      bindButtons();
    </script>
  </body>
</html>
